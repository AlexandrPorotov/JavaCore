package JavaCore;

/*Hash таблицы хранят пары значение ключ-данные (объединение hash функции с массивом).
  Обеспечивают высокую скорость операций и позволяют по-разному моделировать данные.
  Как работает hash функция -
  Например, нам нужно создать список продуктов в магазине с их ценами. Если мы будем искать цену
  обычным поиском или даже бинарным, это займет время. Гораздо лучше найти значение цены сразу же.
  Так вот hash функция на вход принимает данные, а на выходе мы получаем значение, например номер ячейки массива
  куда запишем цену. Таким образом мы мгновенно получаем доступ к цене, передавая строку с названием продукта
  В целом, реализацию hash таблиц придумывать не надо, тк они уже есть в стандартных комплектах языков программирования.
  Однако в конце данного класса, будет описание работы hash таблиц.*/

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class HashMapLearn {

    public static void main(String[] args) {

        /*создание hash таблицы (далее "мапа")*/
        HashMap<Integer, String> hashMap = new HashMap<>(); /*Integer - Ключ, String - значение*/

        /*будем использовать в примере номера паспортов и ФИО
          ФИО может быть одинаковым, однако серия и номер паспорта, всегда уникальны*/

        /*добавление значений в мапу*/
        hashMap.put(212133,"Иван Иванович Иванов");
        hashMap.put(162348, "Петр Петрович Петров");
        hashMap.put(8082771, "Владимир Ильич Ленин");

        System.out.println(hashMap); /* переопределенный метод toString(), поэтому ее можно выводить на консоль. */
        /*{212133=Иван Иванович Иванов, 8082771=Владимир Ильич Ленин, 162348=Петр Петрович Петров}*/

        /*если использовать уже существующий ключ, то элемент в мапе перезапишется*/
        hashMap.put(162348,"Новая запись");

        System.out.println(hashMap);
        /*{212133=Иван Иванович Иванов, 8082771=Владимир Ильич Ленин, 162348=Новая запись}*/
        /*“Ключ” назвали ключом не просто так. Доступ к значениям в HashMap осуществляется по ключу
           (но никак не наоборот — ключ нельзя получить по значению, ведь значения могут быть повторяющимися). */


        /*Методы получения значения по ключу и удаления записи, опять же по ключу*/
        String name = hashMap.get(8082771);
        System.out.println(name);

        /*Владимир Ильич Ленин*/

        hashMap.remove(8082771);
        System.out.println(hashMap);

        /*{212133=Иван Иванович Иванов, 162348=Новая запись}*/

        /*Мы можем проверить содержится ли в списке какой-то конкретный элемент
          причем для обеих частей пары: у нее есть методы containsKey()(проверяет наличие какого-то ключа)
          и containsValue() (проверяет наличие значения). */

        System.out.println(hashMap.containsKey(162348)); /* true */
        System.out.println(hashMap.containsKey(112222)); /* false */
        System.out.println(hashMap.containsValue("Иван Иванович Иванов")); /* true */

        /*Получение всех ключей и значений по отдельности */

        Set<Integer> keys = hashMap.keySet(); /*Коллекция Set не может хранить одинаковые значения */
        System.out.println("Keys - " + keys); /*Keys - [212133, 162348]*/

        ArrayList<String> values = new ArrayList<>(hashMap.values());
        System.out.println("Values - " + values); /*Values - [Иван Иванович Иванов, Новая запись]*/

        /*Методы
            size() - возвращает число элементов в мапе.
            clear() - удаляет все элементы.
         */

        System.out.println(hashMap.size()); /* 2 */

        hashMap.clear();

        System.out.println(hashMap); /* {} */

        /* isEmpty() - проверяет есть ли хоть один элемент в мапе*/

        System.out.println(hashMap.isEmpty()); /* true */

        /* Так же мы можем соединить две мапы в одну, при помощи метода putAll() */

        HashMap<Integer, String> hashMap1 = new HashMap<>();
        HashMap<Integer, String> hashMap2 = new HashMap<>();

        hashMap1.put(1111, "aaa");
        hashMap1.put(2222, "bbb");
        hashMap1.put(3333, "ccc");

        hashMap2.put(4444, "ddd");
        hashMap2.put(5555, "iii");

        hashMap1.putAll(hashMap2);

        System.out.println(hashMap1);
        /* {5555=iii, 3333=ccc, 1111=aaa, 4444=ddd, 2222=bbb} */

        /*перебор мапы с помощью цикла for */

        for (Map.Entry<Integer, String> entry: hashMap1.entrySet()) {
            System.out.println(entry);
        }

        /*5555=iii
          3333=ccc
          1111=aaa
          4444=ddd
          2222=bbb*/

        /* Интерфейс Map.Entry обозначает как раз пару “ключ-значение” внутри мапы.
          Метод entrySet() возвращает список всех пар в нашей HashMap
          (поскольку наша мапа состоит как раз из таких пар-Entry, то мы перебираем именно пары, а не отдельно ключи или значения). */

        /* доп информация https://habr.com/ru/post/128017/ */
    }

    /*Хеш-таблицей называется структура данных, реализующая интерфейс ассоциативного массива
    (абстрактная модель «ключ – значение» или entry), которая обеспечивает очень быструю вставку и поиск:
    независимо от количества элементов вставка и поиск (а иногда и удаление) выполняются за время, близкое к константе – O(1).
    По сути, это обычный массив, где местоположение элемента зависит от значения самого элемента.
    Связь между значением элемента и его позицией в хеш-таблице задает хеш-функция.*/

    /*Хеш-функция получает входную часть данных, которую мы называем ключом, а на выходе она выдает целое число,
    известное как хеш-значение (или хеш-код). Затем, хеш-значение привязывает наш ключ к определенному индексу хеш-таблицы.
    Для основных операций: вставки, поиска и удаления мы используем одну и ту же хеш-функцию, поэтому эти операции осуществляются довольно быстро.
    По этой причине важно, чтобы хеш-функция вела себя последовательно и выводила один и тот же индекс для одинаковых входных данных.*/

    /* принцип работы hash map в java - https://javarush.ru/groups/posts/2496-podrobnihy-razbor-klassa-hashmap */
}
